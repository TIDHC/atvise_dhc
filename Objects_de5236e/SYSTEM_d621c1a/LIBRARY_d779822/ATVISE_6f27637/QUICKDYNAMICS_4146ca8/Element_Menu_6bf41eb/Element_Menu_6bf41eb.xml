<?xml version="1.0" encoding="UTF-8"?>
<script>
  <metadata>
    <icon type="image/png">iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADbElEQVRYhe2Wb2gbdRjHzxdLXbvVbfSWlLW7tZ6tVev+GSejaVJyaeY2EN3qWEFJWwT/MLFik1Vk5yjHCJ1/2AudWjBsUvCVhBG2puksy01GKANH56ytiDBTZNTVUYwdbT6+kJXNpO7usimCB8+bg9/3+/k9z3P3PAL/8iNYOTR15WfeOdRN6zMeHqhyIAgCy0qW0tT4BPtDQVKp1N0BuDb1Ey8/ryBXLqfnhRrOfexk+pQHdIWrpzyc+2QrPS8+irzOTpPbxejo6J0D0E/2USst52jXw8ydUUDPH1ndx9wZP0e7nYhlK4lEIoUDJE+8i1xRzDefbV3UOAck6eNSfyNrK1bT19dnHSB96STVa4r5tt+4+c3ZGPu8idXiKkZGRiwAzF7lKY9E5K1HFkS/PLIJta3KUKArZM/6Odbjxrl5o3mA7/QPqL9/GdmkdwFAbatCEARDcePMvN5MfZ3E4OCgcYDs/CyhdifvvVpzS1rNZuBGKd4PumlvD+QCFBUV5aVfV34vjetX8HVki+na5zakwoV+P3W1ci5AV1cXqqrmxIeH38C25B4yQ023iFkpAbrCb0NeimxLcgHymauqykeHX88RKQQAXfnzneEemPkBuaKEyair4BKgK6RPKJSVrTIBMPsLz+2QifVuLLwJkz5iR5rxuBuMAwB8eqiFjp1rCi5BVvfT0eIkHA6bA7h+5TyV9qVc/sJlOQPZpMLlqI+VK0qZnJw0BwBZIuG9PO22W/8E9W20PLme7u79eR1uP4yuX2OPX+Zgh2ze/Ow2Dr70OJs3bSCTyVgEAOZ+n2Knu5p9u9eSGfLe3jjpI3Pax77WDTxU9yDpdHpRbcP7wPzcLOE391Ivl3L8QD2/DnqZT96caoXsVzvInFY4/vZj1FSXs3vXLqanp/9W1/RK9uP3F3mlbTvlZcU0bxF57dlKDrRV09lay/ZGmftKS2j2eRkYGDCkZ2knBAgGg3R2diIIAqqq0tvby/DwMDMzM6Z0LAM0NDQQi8Xy/l7vOkA8HkeSJMbHx3E4HP8sQDwex263k0gk0DSNQCB3xpsCWGwa/jVCoRAulwtJkkgkEqRSKURRZGxsrDCAUChkCEDTNGKxGBMTE2iahiiKRKPRgswBBJvNZni4CIKAw+EgEAgUfPMFgDui8j/AfxngD/18GCbKyZ9dAAAAAElFTkSuQmCC</icon>
    <visible>1</visible>
    <title>Element Menu</title>
    <description>Adds a menu to a visual component.</description>
  </metadata>
  <parameter behavior="hidden" name="id" valuetype="string"/>
  <parameter behavior="hidden" defaultvalue="" name="elementId" valuetype="string"/>
  <parameter behavior="optional" config="top-left;top-right;bottom-left;bottom-right" defaultvalue="" description="menu positioning" name="elementPosition" valuetype="enum"/>
  <parameter behavior="optional" config="yes;no" defaultvalue="" description="menu mouseover active" name="fadeInAtHover" valuetype="enum"/>
  <parameter behavior="optional" defaultvalue="" description="menu mouseover delay (ms)" name="fadeInAtHoverTime" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="menu mouseout delay (ms)" name="fadeInAtHoverHide" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="menu group" name="elementGroup" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu items set" name="elementDefaultMenu" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 1 text" name="menue_1_text" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 1 trigger" name="menue_1_trigger" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 1 value" name="menue_1_value" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 2 text" name="menue_2_text" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 2 trigger" name="menue_2_trigger" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 2 value" name="menue_2_value" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 3 text" name="menue_3_text" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 3 trigger" name="menue_3_trigger" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 3 value" name="menue_3_value" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 4 text" name="menue_4_text" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 4 trigger" name="menue_4_trigger" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 4 value" name="menue_4_value" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 5 text" name="menue_5_text" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 5 trigger" name="menue_5_value" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu item 5 value" name="menue_5_trigger" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol" name="elementSymbol" valuetype="string"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol scaling (0..100)" name="elementSymbolScale" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol color" name="elementColor" valuetype="color"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol background" name="elementBackground" valuetype="color"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol size x" name="elementSizeX" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol size y" name="elementSizeY" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol offset x" name="elementOffsetX" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol offset y" name="elementOffsetY" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol border color" name="elementBorderColor" valuetype="color"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol border radius" name="elementBorderRadius" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="menu symbol border width" name="elementBorderSize" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="context menu offset x" name="contextOffsetX" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="context menu offset y" name="contextOffsetY" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="context menu click frame" name="clickareaEnlargement" valuetype="number"/>
  <parameter behavior="optional" defaultvalue="" description="element event target" name="elementEventTarget" valuetype="string"/>
  <code><![CDATA[/**
 * This quick dynamic adds a menu to a visual component
 *
 */
var elementMenuConfig = webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Element Menu Manager");

var ElementMenuQD = function (document) {
	var self = this;
	var debug = false;

	/**
	 * DECLARATIONS
	 */
	var id = base.elementId ? base.elementId : webMI.gfx.elementPrefix + base.id;
	var elementGroup = base.elementGroup ? base.elementGroup : false;
	var elementEventTarget = base.elementEventTarget ? base.elementEventTarget : false;

	var prefixId = base.id ? webMI.gfx.elementPrefix + base.id : webMI.gfx.elementPrefix ? webMI.gfx.elementPrefix.slice(0, -1) : null;
	var menuId = elementMenuConfig.getUniqueSymbolID(prefixId);

	var baseConfiguration = {
		id: base.id,
		elementSymbol: base.elementSymbol,
		elementSymbolScale: base.elementSymbolScale,
		elementPosition: base.elementPosition,
		elementSizeX: base.elementSizeX,
		elementSizeY: base.elementSizeY,
		elementOffsetX: base.elementOffsetX,
		elementOffsetY: base.elementOffsetY,
		elementBorderSize: base.elementBorderSize,
		elementBorderRadius: base.elementBorderRadius,
		elementBorderColor: base.elementBorderColor,
		elementColor: base.elementColor,
		elementBackground: base.elementBackground,
		contextOffsetX: base.contextOffsetX,
		contextOffsetY: base.contextOffsetY,
		fadeInAtHover: base.fadeInAtHover,
		fadeInAtHoverTime: base.fadeInAtHoverTime,
		fadeInAtHoverHide: base.fadeInAtHoverHide
	};


	/** set custom configs **/
	var globalConfiguration = elementMenuConfig.getConfiguration();
	var customPositionIndex = base.customElementPosition ? base.customElementPosition :
		baseConfiguration.elementPosition ? baseConfiguration.elementPosition : globalConfiguration.elementPosition;

	if (base.customElementPosition) {
		baseConfiguration.elementPosition = base.customElementPosition;
	}

	if (base.customFadeInAtHover) {
		baseConfiguration.fadeInAtHover = base.customFadeInAtHover;
	}

	if (base.customElementOffsetX) {
		baseConfiguration.elementOffsetX = base.customElementOffsetX;
	} else if (base.customElementLayoutOffsets && base.customElementLayoutOffsets[customPositionIndex]) {
		baseConfiguration.elementOffsetX = base.customElementLayoutOffsets[customPositionIndex].x;
	}

	if (base.customElementOffsetY) {
		baseConfiguration.elementOffsetY = base.customElementOffsetY;
	} else if (base.customElementLayoutOffsets && base.customElementLayoutOffsets[customPositionIndex]) {
		baseConfiguration.elementOffsetY = base.customElementLayoutOffsets[customPositionIndex].y;
	}

	if (base.customClickareaEnlargement) {
		baseConfiguration.clickareaEnlargement = base.customClickareaEnlargement;
	}


	/** set config **/
	var configuration = _getConfiguration();
	var configurationSymbol = {
		background: configuration.elementBackground,
		borderColor: configuration.elementBorderColor,
		color: configuration.elementColor,
		fadeInAtHover: configuration.fadeInAtHover,
		fontSize: configuration.elementSizeX < configuration.elementSizeY ? configuration.elementSizeX : configuration.elementSizeY,
		fontScale: configuration.elementSymbolScale,
		icon: configuration.elementSymbol,
		parent: true
	}

	var contextMenu = {};
	var contextMenuStructure = [];
	var contextMenuEnabled = true;
	var contextMenuReady = false;
	var contextMenuDestroy = false;

	var defaultContextMenuStyle = {
		itemHeight: 25,
		maxRows: 5,
		fontFill: "#575757",
		hoverFontFill: "#333333",
		fill: "#f1f1f1",
		stroke: "#e5e5e5",
		strokeWidth: 0,
		hoverFill: "#e5e5e5",
		closeTime: 0,
	};

	var elementLayoutFixes = base.elementLayoutFixes;

	var hoverID = null;
	var hoverTiming = {
		iTime: 0,
		oTime: 0,
		miTime: configuration.fadeInAtHoverTime, // time for delay mouseover
		moTime: configuration.fadeInAtHoverHide	// time for delay to hide
	}

	var menuTimeoutList = [];


	/**
	 * RUNTIME
	 */
	_showMenuSymbol(document);
	_setMenu([]);
	_initMenu();


	/**
	 * FUNCTIONS
	 */

	/**
	 * Adding a menu structur to the existing menu
	 * @param menuConfig
	 */
	this.addMenu = function (menuConfig) {
		/* repeat if symbol not ready  */
		if (!contextMenuReady) {
			var timer = setTimeout(function () {
				if (contextMenuDestroy)
					return;

				self.addMenu(menuConfig);
			}, 125);
			menuTimeoutList.push(timer);
			return;
		}

		_addMenu(menuConfig);
	}


	/**
	 * clean up lost timeouts and other stuff
	 */
	this.destroy = function () {
		contextMenuDestroy = true;
		for (var t in menuTimeoutList) {
			clearTimeout(menuTimeoutList[t]);
			menuTimeoutList[t] = null;
		}
	}


	/**
	 * Get predefines start order of menue types
	 * @param type
	 * @returns {*}
	 */
	this.getStartOrder = function (type) {
		return elementMenuConfig.getStartOrder(type);
	}


	/**
	 * Get unique symbol id for foreign object container
	 * @param id
	 * @returns {*}
	 */
	self.getUniqueSymbolID = function (id) {
		return elementMenuConfig.getUniqueSymbolID(id);
	}


	/**
	 * init context menu
	 * @param cfg
	 */
	this.initContextMenu = function (cfg) {
		if (!cfg)
			return;

		if (cfg.fadeInAtHover) {
			configuration.fadeInAtHover = cfg.fadeInAtHover;
			configurationSymbol.fadeInAtHover = cfg.fadeInAtHover;
		}

		if (cfg["elementDefaultMenu"]) {
			var defaultMenuStructure = elementMenuConfig.getDefaultMenuItems(cfg["elementDefaultMenu"]);
			_addMenu(defaultMenuStructure);
			self.setVisibility(true);
		}

		var elementMenuConfiguration = [];

		var order = elementMenuConfig.getStartOrder("default");
		var orderSteps = order["steps"];
		var orderStart = order["start"] - orderSteps;

		for (var i = 1; i < 6; i++) {
			if (cfg["menue_" + i + "_text"]) {
				orderStart = orderStart + orderSteps;
				elementMenuConfiguration.push({
					mid: "menue_" + i,
					text: cfg["menue_" + i + "_text"],
					value: cfg["menue_" + i + "_value"],
					trigger: cfg["menue_" + i + "_trigger"],
					order: orderStart
				});
			}
		}

		if (elementMenuConfiguration.length > -1) {
			_addMenu(elementMenuConfiguration);
			self.setVisibility(true);
		}
	}


	/**
	 * Removing a menu structur from an existing menu
	 * @param menuConfig
	 */
	this.removeMenu = function (menuConfig) {
		/* repeat if symbol not ready  */
		if (!contextMenuReady) {
			var timer = setTimeout(function () {
				if (contextMenuDestroy)
					return;

				self.removeMenu(menuConfig);
			}, 125);
			menuTimeoutList.push(timer);
			return;
		}

		_removeMenu(menuConfig);
	}


	/**
	 * set a new menu structur
	 * this will also remove/replace all existing items
	 * @param menuConfig
	 */
	this.setMenu = function (menuConfig) {
		/* repeat if symbol not ready  */
		if (!contextMenuReady) {
			var timer = setTimeout(function () {
				if (contextMenuDestroy)
					return;

				self.setMenu(menuConfig);
			}, 125);
			menuTimeoutList.push(timer);
			return;
		}

		_setMenu(menuConfig);
	}


	/**
	 * set symbol for menu
	 * @param symbol
	 */
	this.setSymbol = function (symbol) {
		/* repeat if symbol not ready  */
		if (!contextMenuReady) {
			var timer = setTimeout(function () {
				if (contextMenuDestroy)
					return;

				self.setSymbol(symbol);
			}, 125);
			menuTimeoutList.push(timer);
			return;
		}

		_setSymbol(symbol);
	}


	/**
	 * change visibility of the menu (symbol)
	 * @param visible
	 */
	this.setVisibility = function (visible) {
		/* repeat if symbol not ready  */
		if (!contextMenuReady) {
			var timer = setTimeout(function () {
				if (contextMenuDestroy)
					return;

				self.setVisibility(visible);
			}, 125);
			menuTimeoutList.push(timer);
			return;
		}

		_setVisibility(visible);
	}


	/**
	 * change visibility by parent settings
	 * e.g. parent gets hidden, so menu gets hidden
	 */
	this.updateByParentVisibility = function () {
		/* repeat if not ready  */
		if (!contextMenuReady) {
			var timer = setTimeout(function () {
				if (contextMenuDestroy)
					return;

				self.updateByParentVisibility();
			}, 250);
			menuTimeoutList.push(timer);
			return;
		}

		var element;

		/* get element */
		if (base.elementId) {
			element = document.getElementById(base.elementId).parentNode;
		} else {
			element = document.getElementById(id);
			if (!element)
				element = document.getElementById(base.id);
		}

		try {
			configurationSymbol.parent = window.getComputedStyle(element).visibility == "visible";
		} catch (ex) {
			console.error("Error get getComputedStyle @:" + id + " (" + base.elementId + ")");
		}

		if (configurationSymbol.fadeInAtHover == "yes")
			_setVisibility(false);
		else
			_setVisibility(configurationSymbol.parent);
	}


	/**
	 * add hover function to element
	 * @private
	 */
	function _addHover(document) {
		var element;

		try {
			/* get svg element */
			if (base.elementId) {
				element = document.getElementById(base.elementId).parentNode.parentNode;
			} else {
				element = document.getElementById(id);
				if (!element)
					element = document.getElementById(base.id);
				if (element.tagName === "svg") {
					element = element.parentNode;
				}
			}

			/* add events to element */
			webMI.addEvent(element, ["mouseover", "touchstart"], hoverStart);
			webMI.addEvent(element, ["mouseout", "touchend"], hoverReset);

			/* get further element like clickareasFO */
			if (elementEventTarget) {
				if (!Array.isArray(elementEventTarget))
					elementEventTarget = [elementEventTarget];

				for (var eet in elementEventTarget) {
					let furtherElement = webMI.rootWindow.document.getElementById(elementEventTarget[eet]);
					webMI.addEvent(furtherElement, ["mouseover", "touchstart"], hoverStart);
					webMI.addEvent(furtherElement, ["mouseout", "touchend"], hoverReset);
				}
			}

			/* start hover */
			function hoverStart(e) {
				hoverTiming.iTime = Date.now();
				if (!hoverTiming.oTime)
					hoverTiming.oTime = hoverTiming.iTime;

				if (!hoverID) {
					hoverID = setTimeout(function showIconAfterMouseOver() {
						if (contextMenuDestroy)
							return;

						if (hoverTiming.iTime === hoverTiming.oTime) {
							_setVisibility(true, true);
						}

						if (configurationSymbol.fadeInAtHover.toLowerCase() === "yes") {
							var timer = setTimeout(function hideIconAfterMouseOver() {
								hoverID = null;

								if (contextMenuDestroy)
									return;

								if (configurationSymbol.fadeInAtHover.toLowerCase() === "yes")
									_setVisibility(false);

							}, hoverTiming.moTime);
							menuTimeoutList.push(timer);
						}
					}, hoverTiming.miTime);
					menuTimeoutList.push(hoverID);
				}
			}

			/* end hover */
			function hoverReset(e) {
				hoverTiming.oTime = 0;
			}

		} catch (ex) {
			console.error("Error initializing the hover function @:" + id + " (" + base.elementId + ")");
		}
	}


	/**
	 * adding menu items to existing menu
	 * existing items will be replaced!
	 * @param menuConfig
	 * @private
	 */
	function _addMenu(menuConfig) {
		if (menuConfig) {
			var context = _concatRaw(contextMenuStructure, menuConfig);
			contextMenuStructure = _sortRaw(context);
			_buildContexMenu();
		}
	}


	/**
	 * build the context menu out of the stored structure
	 * @private
	 */
	function _buildContexMenu() {
		contextMenu = {};
		contextMenuStructure.forEach(function (obj, n) {
			obj.id = base.id ? webMI.gfx.elementPrefix + base.id : webMI.gfx.elementPrefix.slice(0, -1);
			obj.fkt = null;

			if (obj.trigger) {
				obj.fkt = function () {
					webMI.trigger.fire(obj.trigger, {
						id: obj.id,
						value: obj.value
					});
				};
			} else if (typeof (obj.value) === "function") {
				obj.fkt = obj.value;
			} else if (obj.value) {
				obj.fkt = obj.value;
			}

			if (obj.sub) {
				contextMenu[obj.text] = {
					text: obj.text, textAlign: "left", sub: obj.sub
				};
			} else {
				contextMenu[obj.mid] = {
					text: obj.text, textAlign: "left", value: obj.fkt
				};
			}
		});
	}


	/**
	 * concat two menu structures
	 * @param context ... reserved for old structure
	 * @param structur .. reserved for new elements
	 * @returns {*}
	 * @private
	 */
	function _concatRaw(context, structur) {
		var objStructur = structur.slice(0);
		var objContext = context.slice(0);

		for (var s in objStructur) {
			var sItem = objStructur[s];

			var order = 0;
			for (var c in objContext) {
				var cItem = objContext[c];

				if (sItem.mid === cItem.mid) {
					order = c;
					break;
				}
				order++;
			}

			objContext[order] = objStructur[s];
		}

		return objContext;
	}


	/**
	 * returns configuration
	 * @returns {{...}}
	 */
	function _getConfiguration() {

		/* fix for differnce between zoom and transform */
		var transformFix = 1;
		if (scaleType === "transform") {
			transformFix = 1.15;
		}

		return {
			id: base.elementId ? base.elementId : base.id,
			elementSymbol: baseConfiguration.elementSymbol
				? baseConfiguration.elementSymbol
				: globalConfiguration.elementSymbol,
			elementSymbolScale: baseConfiguration.elementSymbolScale
				? parseInt(baseConfiguration.elementSymbolScale) / 100
				: globalConfiguration.elementSymbolScale,
			elementPosition: baseConfiguration.elementPosition
				? baseConfiguration.elementPosition
				: globalConfiguration.elementPosition,
			elementSizeX: (baseConfiguration.elementSizeX
				? parseInt(baseConfiguration.elementSizeX)
				: globalConfiguration.elementSizeX) * transformFix,
			elementSizeY: (baseConfiguration.elementSizeY
				? parseInt(baseConfiguration.elementSizeY)
				: globalConfiguration.elementSizeY) * transformFix,
			elementOffsetX: (baseConfiguration.elementOffsetX
				? parseInt(baseConfiguration.elementOffsetX)
				: globalConfiguration.elementOffsetX) * transformFix,
			elementOffsetY: (baseConfiguration.elementOffsetY
				? parseInt(baseConfiguration.elementOffsetY)
				: globalConfiguration.elementOffsetY) * transformFix,
			elementBorderSize: baseConfiguration.elementBorderSize
				? parseInt(baseConfiguration.elementBorderSize)
				: globalConfiguration.elementBorderSize,
			elementBorderRadius: baseConfiguration.elementBorderRadius
				? parseInt(baseConfiguration.elementBorderRadius)
				: globalConfiguration.elementBorderRadius,
			elementBorderColor: baseConfiguration.elementBorderColor
				? baseConfiguration.elementBorderColor
				: globalConfiguration.elementBorderColor,
			elementColor: baseConfiguration.elementColor
				? baseConfiguration.elementColor
				: globalConfiguration.elementColor,
			elementBackground: baseConfiguration.elementBackground
				? baseConfiguration.elementBackground
				: globalConfiguration.elementBackground,
			// context menu
			contextOffsetX: (baseConfiguration.contextOffsetX
				? parseInt(baseConfiguration.contextOffsetX)
				: globalConfiguration.contextOffsetX) * transformFix,
			contextOffsetY: (baseConfiguration.contextOffsetY
				? parseInt(baseConfiguration.contextOffsetY)
				: globalConfiguration.contextOffsetY) * transformFix,
			// handler
			fadeInAtHover: baseConfiguration.fadeInAtHover
				? baseConfiguration.fadeInAtHover
				: globalConfiguration.fadeInAtHover,
			fadeInAtHoverTime: baseConfiguration.fadeInAtHoverTime
				? parseInt(baseConfiguration.fadeInAtHoverTime)
				: globalConfiguration.fadeInAtHoverTime,
			fadeInAtHoverHide: baseConfiguration.fadeInAtHoverHide
				? baseConfiguration.fadeInAtHoverHide
				: globalConfiguration.fadeInAtHoverHide,
			clickareaEnlargement: baseConfiguration.clickareaEnlargement
				? baseConfiguration.clickareaEnlargement
				: globalConfiguration.clickareaEnlargement
		};
	}


	/**
	 * init menu, set visible, add hover events
	 * @private
	 */
	function _initMenu() {
		var clickContainer = webMI.rootWindow.document.getElementById(menuId + "_event_target");
		if (!clickContainer) {
			// console.warn("Wait for: " + menuId + "_event_target");
			var timer = setTimeout(function () {
				if (contextMenuDestroy)
					return;
				_initMenu();
			}, 25);
			menuTimeoutList.push(timer);
		} else {
			// console.warn("Menu "+menuId + "_event_target"+" ready");

			if (Object.keys(contextMenu).length > 0) {
				_setVisibility(true);
			} else {
				_setVisibility(false);
			}

			if (configurationSymbol.fadeInAtHover.toLowerCase() === "yes") {
				_addHover(document);
			}

			contextMenuReady = true;
		}
	}


	/**
	 * remove menu items from existing menu
	 * existing items will be replaced!
	 * @param menuConfig
	 * @private
	 */
	function _removeMenu(menuConfig) {
		if (menuConfig) {

			var context = _removeRaw(contextMenuStructure, menuConfig);
			contextMenuStructure = _sortRaw(context);
			_buildContexMenu();

		}
	}


	/**
	 * remove menu structures from structure
	 * @param context ... reserved for old structure
	 * @param structur .. reserved for new elements
	 * @returns {*}
	 * @private
	 */
	function _removeRaw(context, structur) {
		var objStructur = structur.slice(0);
		var objContext = context.slice(0);

		for (var s in objStructur) {
			var sItem = objStructur[s];

			var order = 0;
			for (var c in objContext) {
				var cItem = objContext[c];

				if (sItem.mid === cItem.mid) {
					delete objContext[c]
				}
			}
		}

		return objContext;
	}


	/**
	 * set menu items
	 * this will override the existing structure
	 * @param menuConfig
	 * @private
	 */
	function _setMenu(menuConfig) {
		if (menuConfig) {
			contextMenuStructure = [];

			var context;
			var defaultMenuStructure = elementMenuConfig.getDefaultMenuItems(base.elementDefaultMenu);

			context = _concatRaw(contextMenuStructure, menuConfig);
			contextMenuStructure = _sortRaw(context);

			context = _concatRaw(contextMenuStructure, defaultMenuStructure);
			contextMenuStructure = _sortRaw(context);

			_buildContexMenu();

			if (contextMenuReady) {
				_setVisibility(true);
			}
		}
	}


	/**
	 * setting visibility of icon
	 * @param visible
	 * @param hover
	 * @param ctn ... internal retry counter to prevent deadlooks
	 * @private
	 */
	function _setVisibility(visible, hover) {
		/* set symbol visibility */
		var click = webMI.rootWindow.document.getElementById(menuId + "_event_target");
		var icon = webMI.rootWindow.document.getElementById(menuId + "_icon_container");
		var svgMenu = document.getElementById(menuId);

		if (configurationSymbol.fadeInAtHover.toLowerCase() === "yes") {
			visible = false;
		}

		if (!configurationSymbol.parent) {
			visible = false;
			hover = false;
		}

		try {
			if ((visible || hover) && Object.keys(contextMenu).length > 0) {
				svgMenu.setAttribute("visibility", "visible");
				click.parentNode.style.display = "block";
				icon.parentNode.style.display = "block";
			} else {
				svgMenu.setAttribute("visibility", "hidden");
				click.parentNode.style.display = "none";
				icon.parentNode.style.display = "none";
			}
		} catch (ex) {
			// console.error("Error initializing the visibility @:" + menuId);
		}
	};


	/**
	 * set symbol for menu
	 * @param symbol
	 * @private
	 */
	function _setSymbol(symbol) {
		var icon = webMI.rootWindow.document.getElementById(menuId + "_icon_container");
		var iconSymbol = webMI.rootWindow.document.getElementById(menuId + "_icon_symbol");

		if (!iconSymbol)
			return; /* content already unloaded */

		/* custom symbol */
		configurationSymbol.icon = symbol.icon ? symbol.icon : configuration.elementSymbol;
		configurationSymbol.color = symbol.color ? symbol.color : configuration.elementColor;
		configurationSymbol.fontScale = symbol.fontScale ? symbol.fontScale / 100 : configuration.elementSymbolScale;
		configurationSymbol.background = symbol.background ? symbol.background : configuration.elementBackground;
		configurationSymbol.borderColor = symbol.borderColor ? symbol.borderColor : configuration.elementBorderColor;
		configurationSymbol.fadeInAtHover = symbol.visible ? "no" : configuration.fadeInAtHover;

		/* update symbol */
		iconSymbol.innerHTML = "";

		var dim = parseFloat(iconSymbol.parentNode.style.width - iconSymbol.parentNode.style.borderWidth) / configuration.elementSizeX;

		var divDim = {
			width: Math.floor((configuration.elementSizeX - configuration.elementBorderSize * 2) * dim),
			height: Math.floor((configuration.elementSizeY - configuration.elementBorderSize * 2) * dim),
			borderRadius: Math.floor(configuration.elementBorderRadius * dim),
			borderWidth: Math.floor(configuration.elementBorderSize * dim),
			fontSize: Math.floor(configurationSymbol.fontSize * configurationSymbol.fontScale * dim)
		}

		var isImage = false;
		var extensions = ["jpg", "jpeg", "gif", "png", "svg", "webp", "ico"];
		for (var i in extensions) {
			if (configurationSymbol.icon.indexOf("." + extensions[i]) > -1) isImage = true;
		}

		icon.style.background = configurationSymbol.background;
		icon.style.borderRadius = divDim.borderRadius + "px";
		icon.style.borderWidth = divDim.borderWidth + "px";
		icon.style.borderStyle = "solid";
		icon.style.borderColor = configurationSymbol.borderColor;

		if (isImage) {
			var iconContainerImage = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
			iconContainerImage.src = configurationSymbol.icon;
			iconContainerImage.style.width = configuration.elementSizeX * configurationSymbol.fontScale + "px";
			iconContainerImage.style.height = configuration.elementSizeY * configurationSymbol.fontScale + "px";
			iconContainerImage.style.pointerEvents = "none";
			iconSymbol.appendChild(iconContainerImage);
		} else {
			iconSymbol.style.color = configurationSymbol.color;
			iconSymbol.style.fontSize = divDim.fontSize + "px";
			iconSymbol.innerHTML = configurationSymbol.icon;
		}

		icon.style.pointerEvents = "none";
		icon.parentNode.style.pointerEvents = "none";

		iconSymbol.style.pointerEvents = "none";
		iconSymbol.style.display = "flex";
		iconSymbol.style.justifyContent = "center";
		iconSymbol.style.alignItems = "center";

		if (configurationSymbol.fadeInAtHover.toLowerCase() === "no") {
			_setVisibility(true, symbol.visible ? true : false);
		} else {
			_setVisibility(false);
		}
	}


	/**
	 * prepare notification icon
	 * and event lister for the context menu
	 */
	function _showMenuSymbol(document) {
		if (webMI.gfx.getVisible(configuration.id) === false)
			return;

		var svgMenu = document.getElementById(menuId);

		/* add menu group to svg if not exists */
		if (!svgMenu) {

			/* get element bound */
			var element;
			var elementAbsolute = true;

			if (base.elementId) {
				element = document.getElementById(base.elementId).parentNode.parentNode;
				elementAbsolute = false;
			} else {
				element = document.getElementById(id);

				if (!element) {
					element = document.getElementById(configuration.id);
					if (!element)
						return;
				}

				try {
					if (element.tagName === "svg") {
						element = element.parentNode;
					}
				} catch (ex) {
					console.error("invalide configuration");
				}
			}

			var svgRoot = element;
			var gMatrix = element.getAttribute("transform") ? element.transform.baseVal.consolidate().matrix : false;

			while (svgRoot.tagName !== "svg")
				svgRoot = svgRoot.parentNode;

			var elementBound = element.getBBox();
			var elementBoundCM = element.getBBox();
			var elementIsRight = configuration.elementPosition.indexOf("right") > -1;
			var elementIsBottm = configuration.elementPosition.indexOf("bottom") > -1;

			/* fix bounding for context menu */
			elementBoundCM.x = elementAbsolute ? elementBoundCM.x : 0;
			elementBoundCM.y = elementAbsolute ? elementBoundCM.y : 0;

			var elementScale = {
				offsetX:
				configuration.elementOffsetX,
				offsetY:
				configuration.elementOffsetY,
				sizeX:
				configuration.elementSizeX,
				sizeY:
				configuration.elementSizeY
			}

			var elementContext = {
				offsetX:
					elementScale.sizeX * (elementIsRight ? 0 : -1)
					- elementScale.offsetX * (elementIsRight ? 1 : -1)
					+ elementScale.sizeX / 2
					+ configuration.contextOffsetX,
				offsetY:
					elementScale.sizeY * (elementIsBottm ? 0 : -1)
					- elementScale.offsetY * (elementIsBottm ? 1 : -1)
					+ elementScale.sizeY / 2
					+ configuration.contextOffsetY
			};

			/* Pass on transformations of the reference element or remove them */
			if (gMatrix) {
				elementBound.x = elementBound.x * gMatrix.a;
				elementBound.y = elementBound.y * gMatrix.d;
				elementBound.width = elementBound.width * gMatrix.a;
				elementBound.height = elementBound.height * gMatrix.d;
				elementScale.sizeX = elementScale.sizeX * gMatrix.a;
				elementScale.sizeY = elementScale.sizeY * gMatrix.d;
				elementScale.offsetX = elementScale.offsetX;
				elementScale.offsetY = elementScale.offsetY;
				elementContext.offsetX = elementContext.offsetX / gMatrix.a;
				elementContext.offsetY = elementContext.offsetY / gMatrix.d;
			}

			var menuPosition = {};

			/*
			if (id.indexOf("id_5") > -1 || id.indexOf("id_19") > -1) {
				console.warn(id, elementBoundCM);
				console.warn(id, elementScale);
				console.warn(id, elementContext);
			}
			*/

			switch (configuration.elementPosition) {
				case "top-right":
					menuPosition = {
						x: elementBound.x + elementBound.width - elementScale.offsetX,
						y: elementBound.y - configuration.elementSizeY + elementScale.offsetY,
						cmx: elementBoundCM.x + elementBoundCM.width + elementContext.offsetX,
						cmy: elementBoundCM.y + elementContext.offsetY
					};
					break;
				case "bottom-left":
					menuPosition = {
						x: elementBound.x - configuration.elementSizeX + elementScale.offsetX,
						y: elementBound.y + elementBound.height - elementScale.offsetY,
						cmx: elementBoundCM.x + elementContext.offsetX,
						cmy: elementBoundCM.y + elementBoundCM.height + elementContext.offsetY
					};
					break;
				case "bottom-right":
					menuPosition = {
						x: elementBound.x + elementBound.width - elementScale.offsetX,
						y: elementBound.y + elementBound.height - elementScale.offsetY,
						cmx: elementBoundCM.x + elementBoundCM.width + elementContext.offsetX,
						cmy: elementBoundCM.y + elementBoundCM.height + elementContext.offsetY
					};
					break;
				default:
					menuPosition = {
						x: elementBound.x - configuration.elementSizeX + elementScale.offsetX,
						y: elementBound.y - configuration.elementSizeY + elementScale.offsetY,
						cmx: elementBoundCM.x + elementContext.offsetX,
						cmy: elementBoundCM.y + elementContext.offsetY
					};
					break;
			}

			/* add svg group */
			svgMenu = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			svgMenu.setAttribute('id', menuId);

			svgMenu.setAttribute('visibility', "hidden");

			/* add svg rect as context menu reference */
			var rectSpace = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
			rectSpace.setAttribute('x', menuPosition.x);
			rectSpace.setAttribute('y', menuPosition.y);
			rectSpace.setAttribute('width', configuration.elementSizeX);
			rectSpace.setAttribute('height', configuration.elementSizeY);

			if (debug) {
				rectSpace.setAttribute('fill', "#ff0000");
			} else {
				rectSpace.setAttribute('rx', configuration.elementBorderRadius);
				rectSpace.setAttribute('ry', configuration.elementBorderRadius);
				rectSpace.setAttribute('opacity', 0);
			}

			svgMenu.appendChild(rectSpace);

			/* create container for icon and click area */
			var iconContainer = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
			var clickContainer = document.createElementNS("http://www.w3.org/1999/xhtml", "div");

			/* add fo */
			/* caution: the rendering of the display has a time offset! */
			var timer = setTimeout(function () {
				if (contextMenuDestroy)
					return;

				webMI.gfx.addForeignObject({
					x: -configuration.clickareaEnlargement,
					y: -configuration.clickareaEnlargement,
					width: configuration.elementSizeX + configuration.clickareaEnlargement * 2,
					height: configuration.elementSizeY + configuration.clickareaEnlargement * 2,
					id: menuId + "_event",
					atvType: "elementMenu",
					childNodes: [clickContainer]
				}, rectSpace);

				webMI.gfx.addForeignObject({
					x: 0, // menuPosition.x,
					y: 0, // menuPosition.y,
					width: configuration.elementSizeX,
					height: configuration.elementSizeY,
					id: menuId + "_icon",
					atvType: "elementMenu",
					childNodes: [iconContainer]
				}, rectSpace);

				var dim = parseFloat(iconContainer.parentNode.style.width) / configuration.elementSizeX;

				var clickDim = {
					width: Math.floor((configuration.elementSizeX - configuration.elementBorderSize * 2 + configuration.clickareaEnlargement * 2) * dim),
					height: Math.floor((configuration.elementSizeY - configuration.elementBorderSize * 2 + configuration.clickareaEnlargement * 2) * dim)
				}

				clickContainer.id = menuId + "_event_target";
				clickContainer.style.width = clickDim.width + "px";
				clickContainer.style.height = clickDim.height + "px";

				/* debugging */
				if (false) {
					clickContainer.style.border = "5px dotted #ff0000";
					clickContainer.style.zIndex = "-10000";
				}

				var divDim = {
					width: Math.floor((configuration.elementSizeX - configuration.elementBorderSize * 2) * dim),
					height: Math.floor((configuration.elementSizeY - configuration.elementBorderSize * 2) * dim),
					borderRadius: Math.floor(configuration.elementBorderRadius * dim),
					borderWidth: Math.floor(configuration.elementBorderSize * dim),
					fontSize: Math.floor(configurationSymbol.fontSize * configurationSymbol.fontScale * dim)
				}

				iconContainer.id = menuId + "_icon_container";
				iconContainer.style.width = divDim.width + "px";
				iconContainer.style.height = divDim.height + "px";
				iconContainer.style.display = "flex";
				iconContainer.style.justifyContent = "center";
				iconContainer.style.alignItems = "center";
				iconContainer.style.background = configurationSymbol.background;
				iconContainer.style.borderRadius = divDim.borderRadius + "px";
				iconContainer.style.borderWidth = divDim.borderWidth + "px";
				iconContainer.style.borderStyle = "solid";
				iconContainer.style.borderColor = configurationSymbol.borderColor;

				var isImage = false;
				var extensions = ["jpg", "jpeg", "gif", "png", "svg", "webp", "ico"];
				for (var i in extensions) {
					if (configurationSymbol.icon.indexOf("." + extensions[i]) > -1) isImage = true;
				}

				/* create icon */
				var iconContainerSymbol = document.createElementNS("http://www.w3.org/1999/xhtml", "span");
				iconContainerSymbol.id = menuId + "_icon_symbol";
				iconContainerSymbol.style.display = "flex";
				iconContainerSymbol.style.justifyContent = "center";
				iconContainerSymbol.style.alignItems = "center";

				if (isImage) {
					var iconContainerImage = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
					iconContainerImage.src = configurationSymbol.icon;
					iconContainerImage.style.width = configuration.elementSizeX * configurationSymbol.fontScale + "px";
					iconContainerImage.style.height = configuration.elementSizeY * configurationSymbol.fontScale + "px";
					iconContainerImage.style.pointerEvents = "none";
					iconContainerSymbol.appendChild(iconContainerImage);
				} else {
					iconContainerSymbol.style.color = configurationSymbol.color;
					iconContainerSymbol.style.fontSize = divDim.fontSize + "px";
					iconContainerSymbol.innerHTML = configurationSymbol.icon;
				}

				iconContainer.appendChild(iconContainerSymbol);

				iconContainer.style.pointerEvents = "none";
				iconContainer.parentNode.style.pointerEvents = "none";
				iconContainerSymbol.style.pointerEvents = "none";
			}, 250);
			menuTimeoutList.push(timer);

			/* add event listener for context menu */
			webMI.addEvent(clickContainer, ["click", "touchstart"], function (e) {
				webMI.callExtension("SYSTEM.LIBRARY.ATVISE.QUICKDYNAMICS.Open Element Menu", {
					"clickAreaId": "",
					"closeOnMouseout": "true",
					"fontsize": "12",
					"id": menuId + "_menu",
					"itemsCount": "10",
					"menuObj": contextMenu,
					"minWidth": "180",
					"onEvent": "immediately",
					"style": defaultContextMenuStyle,
					"x": menuPosition.cmx,
					"y": menuPosition.cmy,
				});
			});

			/* append all to the svg root */
			svgRoot.appendChild(svgMenu);

			/* remove menu from dom */
			webMI.addOnunload(function () {
				svgRoot.removeChild(svgMenu);
			})
		}
	}


	/**
	 * sorting a menu structure by order, and id
	 * @param structur
	 * @returns {*}
	 * @private
	 */
	function _sortRaw(structur) {
		var obj = structur.slice(0);
		obj.sort(function (a, b) {
			if (a.order === b.order) {
				return a.mid < b.mid ? -1 : 1;
			}
			return a.order - b.order;
		});
		return obj;
	}


	/**
	 * TRIGGER SECTION
	 */


	/**
	 * listen for additional menu structure changes
	 */
	webMI.trigger.connect("com.atvise.elementMenu.addMenu", function (e) {
		var menuConfig = null;

		if (e.value && e.value[id]) {
			menuConfig = e.value[id];
			self.addMenu(menuConfig);
		}
	});


	/**
	 * listen for additional menu structure changes (groups)
	 */
	webMI.trigger.connect("com.atvise.elementMenu.addMenuForGroup", function (e) {
		var menuConfig = null;

		if (e.value && e.value[elementGroup]) {
			menuConfig = e.value[elementGroup];
			self.addMenu(menuConfig);
		}
	});


	/**
	 * listen for additional menu structure changes
	 */
	webMI.trigger.connect("com.atvise.elementMenu.removeMenu", function (e) {
		var menuConfig = null;

		if (e.value && e.value[id]) {
			menuConfig = e.value[id];
			self.removeMenu(menuConfig);
		}
	});


	/**
	 * listen for additional menu structure changes
	 */
	webMI.trigger.connect("com.atvise.elementMenu.removeMenuFromGroup", function (e) {
		var menuConfig = null;

		if (e.value && e.value[elementGroup]) {
			menuConfig = e.value[elementGroup];
			self.removeMenu(menuConfig);
		}
	});


	/**
	 * listen for new menu structure
	 */
	webMI.trigger.connect("com.atvise.elementMenu.setMenu", function (e) {
		var menuConfig = null;

		if (e.value && e.value[id]) {
			menuConfig = e.value[id];
			self.setMenu(menuConfig);
		}
	});


	/**
	 * listen for new menu structure (groups)
	 */
	webMI.trigger.connect("com.atvise.elementMenu.setMenuForGroup", function (e) {
		var menuConfig = null;

		if (e.value && e.value[elementGroup]) {
			menuConfig = e.value[elementGroup];
			self.setMenu(menuConfig);
		}
	});


	/**
	 * listen for update symbol
	 */
	webMI.trigger.connect("com.atvise.elementMenu.setSymbol", function (e) {
		if (e.value && e.value.id === menuId) {
			self.setSymbol(e.value);
		}
	});


	/**
	 * listen for update symbol  (groups)
	 */
	webMI.trigger.connect("com.atvise.elementMenu.setSymbolForGroup", function (e) {
		if (e.value && e.value[elementGroup]) {
			var symbol = e.value[elementGroup];
			self.setSymbol(symbol);
		}
	});


	/**
	 * global activation and deactivation of all menus
	 */
	webMI.trigger.connect("com.atvise.elementMenu.globalActive", function (e) {
		self.setVisibility(e.value);
		contextMenuEnabled = e.value;
	});


	/**
	 * simple at unload
	 */
	webMI.addOnunload(function () {
		self.destroy();
	});
}


/* ******************************************* */
/* Memory to avoid duplicate menu declarations */
/* ******************************************* */
var _self = this;
var prefixId = base.id ? webMI.gfx.elementPrefix + base.id : webMI.gfx.elementPrefix ? webMI.gfx.elementPrefix.slice(0, -1) : null;
var iid = elementMenuConfig.getUniqueSymbolID(prefixId);

if (prefixId == null)
	return;

if (!_self.ElementMenuIndex) {
	_self.ElementMenuIndex = {};
	_self.visibilityBuffer = null;


}

if (!webMI.rootWindow.elementMenuEventsAttached) {
	webMI.rootWindow.elementMenuEventsAttached = true;

	/**
	 * listen to visibility changes
	 * e.g. parent change to hidden,
	 */
	webMI.addEvent(webMI.rootWindow.webMI.gfx, "visibilitychange", handleVisibilityChange);

	function handleVisibilityChange(e) {

		/* explizit ignore container with */
		var ignoreContainer = [
			"_blinking_frame",
			"_stroke"
		];

		for (var ic in ignoreContainer) {
			if (e.element.id.indexOf(ignoreContainer[ic]) > -1) {
				return;
			}
		}

		/* proceed with allowed container */
		if (_self.visibilityBuffer == null) {
			_self.visibilityBuffer = setTimeout(function () {
				_self.visibilityBuffer = null;

				for (var index in _self.ElementMenuIndex) {
					_self.ElementMenuIndex[index].updateByParentVisibility();
				}
			}, 100);
		}
	}
}


/**
 * clean up at unload
 * remove FO, reset storage
 */
webMI.addOnunload(function () {
	if (_self.ElementMenuIndex[iid]) {
		_self.ElementMenuIndex[iid].setVisibility(false);
		_self.ElementMenuIndex[iid] = null;
		delete _self.ElementMenuIndex[iid];
	}
	_self.ElementMenuIndex = {};
});

/**
 * this codepart will either return an existing menu or a new one
 */
if (_self.ElementMenuIndex[iid]) {
	_self.ElementMenuIndex[iid].initContextMenu(base);
	return _self.ElementMenuIndex[iid];
} else {
	_self.ElementMenuIndex[iid] = new ElementMenuQD(self.document);
	_self.ElementMenuIndex[iid].initContextMenu(base);
	_self.ElementMenuIndex[iid].updateByParentVisibility();
	return _self.ElementMenuIndex[iid];
}

]]></code>
</script>
