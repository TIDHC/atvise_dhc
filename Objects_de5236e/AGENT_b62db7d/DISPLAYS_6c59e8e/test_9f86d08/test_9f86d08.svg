<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<svg height="890" version="1.2" width="1675" xmlns="http://www.w3.org/2000/svg" xmlns:atv="http://webmi.atvise.com/2007/svgext" xmlns:xlink="http://www.w3.org/1999/xlink">
 <defs/>
 <metadata>
  <atv:gridconfig enabled="false" gridstyle="lines" height="20" width="20"/>
  <atv:snapconfig enabled="false" height="10" width="10"/>
 </metadata>
 <script atv:desc="" atv:name="" type="text/ecmascript"><![CDATA[//-----------------------Variable Declaration

//Internal Variables
var address="AGENT.OBJECTS.SCADA";


//Holders
var ip_Array;


webMI.data.call("Variables_Parser", {address:address}, function(e) {
	console.log("Result: ");
    console.log(e);
    var result=e;
    ip_Array=groupByWebSegment(result);
    
    console.log(ip_Array);
});





//-----------------------Functions
function groupByWebSegment(array) {
    const segmentMap = new Map();

    array.forEach(item => {
        // Assuming there's only one key per object
        const key = Object.keys(item)[0];
        const ip = item[key];
        let segment;

        // Special handling for IPs starting with '10.'
        if (ip.startsWith("10.")) {
            segment = ip.split('.').slice(0, 2).join('.');
        } else if (ip.match(/^\d+\.\d+\.\d+\.\d+$/)) {
            // For other IPs, extract the first three elements
            segment = ip.split('.').slice(0, 3).join('.');
        } else {
            // Use the entire IP as segment if it's not in expected format
            segment = ip;
        }

        // Remove the last element from the key
        const modifiedKey = key.split('.').slice(0, -1).join('.');

        // Group keys by segment
        if (!segmentMap.has(segment)) {
            segmentMap.set(segment, []);
        }
        segmentMap.get(segment).push(modifiedKey);
    });

    // Convert the Map into the required array format
    return Array.from(segmentMap, ([segment, keys]) => ({ [segment]: keys }));
}
]]></script>
</svg>
